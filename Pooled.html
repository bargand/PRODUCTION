<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pooled ANOVA Calculator | Agricultural Experimental Designs</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --primary-color: #3498db;
        --secondary-color: #2980b9;
        --success-color: #2ecc71;
        --warning-color: #f39c12;
        --danger-color: #e74c3c;
        --light-color: #ecf0f1;
        --dark-color: #2c3e50;
        --border-radius: 8px;
        --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --transition: all 0.3s ease;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        color: var(--dark-color);
        background-color: #f5f7fa;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
      }

      header {
        text-align: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }

      h1 {
        color: var(--primary-color);
        margin-bottom: 10px;
        font-weight: 700;
      }

      .subtitle {
        color: #7f8c8d;
        font-weight: 300;
      }

      .design-container {
        display: flex;
        gap: 30px;
        margin-bottom: 30px;
      }

      .input-section,
      .output-section {
        flex: 1;
      }

      .section-title {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        color: var(--dark-color);
      }

      .section-title i {
        color: var(--primary-color);
      }

      .input-card,
      .output-card {
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        padding: 25px;
        margin-bottom: 25px;
        transition: var(--transition);
      }

      .output-card:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      textarea {
        width: 100%;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-family: "Courier New", monospace;
        font-size: 14px;
        resize: vertical;
        min-height: 200px;
        margin-bottom: 15px;
        transition: var(--transition);
      }

      textarea:focus {
        border-color: var(--primary-color);
        outline: none;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
      }

      .input-format {
        font-size: 13px;
        color: #7f8c8d;
        margin-bottom: 20px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: var(--border-radius);
      }

      .example-buttons {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .example-btn {
        flex: 1;
        padding: 8px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 12px;
        transition: var(--transition);
      }

      .example-btn:hover {
        background-color: #e9ecef;
      }

      .btn {
        display: inline-block;
        padding: 12px 24px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: var(--transition);
        width: 100%;
      }

      .btn:hover {
        background-color: var(--secondary-color);
        transform: translateY(-2px);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn i {
        margin-right: 8px;
      }

      .btn-secondary {
        background-color: #6c757d;
      }

      .btn-secondary:hover {
        background-color: #5a6268;
      }

      .btn-success {
        background-color: var(--success-color);
      }

      .btn-success:hover {
        background-color: #27ae60;
      }

      .data-info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .info-card {
        background: var(--light-color);
        padding: 15px;
        border-radius: var(--border-radius);
        text-align: center;
        transition: var(--transition);
      }

      .info-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .info-card h3 {
        font-size: 14px;
        color: #7f8c8d;
        margin-bottom: 5px;
      }

      .info-card p {
        font-size: 24px;
        font-weight: 700;
        color: var(--dark-color);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        font-size: 14px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }

      th {
        background-color: #f8f9fa;
        font-weight: 500;
        color: var(--dark-color);
        position: sticky;
        top: 0;
      }

      tr:hover {
        background-color: #f8f9fa;
      }

      .significance {
        font-weight: 700;
      }

      .sig-0 {
        color: var(--success-color);
      }

      .sig-1 {
        color: var(--warning-color);
      }

      .sig-2 {
        color: var(--danger-color);
      }

      .hidden {
        display: none;
      }

      .error-message {
        background-color: #fdecea;
        color: var(--danger-color);
        padding: 15px;
        border-radius: var(--border-radius);
        margin-top: 20px;
        border-left: 4px solid var(--danger-color);
        animation: fadeIn 0.3s ease;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
        margin-right: 10px;
      }

      .help-text {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: var(--border-radius);
      }

      .help-text h3 {
        margin-bottom: 10px;
        color: var(--dark-color);
      }

      .help-text ul {
        padding-left: 20px;
      }

      .help-text li {
        margin-bottom: 8px;
      }

      .treatment-means {
        margin-top: 20px;
      }

      .treatment-means h3 {
        margin-bottom: 15px;
      }

      .export-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .export-btn {
        flex: 1;
      }

      /* Chart styles */
      .chart-container {
        margin-top: 30px;
        position: relative;
        height: 300px;
        width: 100%;
      }

      .chart-title {
        text-align: center;
        margin-bottom: 15px;
        font-weight: 500;
        color: var(--dark-color);
      }

      .charts-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-top: 20px;
      }

      .chart-card {
        flex: 1;
        min-width: 300px;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        padding: 20px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 992px) {
        .design-container {
          flex-direction: column;
        }
      }

      @media (max-width: 768px) {
        .container {
          padding: 15px;
        }

        .data-info-grid {
          grid-template-columns: 1fr 1fr;
        }

        .export-buttons {
          flex-direction: column;
        }
      }

      @media (max-width: 480px) {
        .data-info-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Pooled ANOVA Calculator</h1>
        <p class="subtitle">
          For combining multiple experiments with similar treatments
        </p>
      </header>

      <div class="design-container">
        <div class="input-section">
          <div class="section-title">
            <i class="fas fa-edit"></i>
            <h2>Input Data</h2>
          </div>

          <div class="input-card">
            <div class="example-buttons">
              <button class="example-btn" id="example1">Load Example 1</button>
              <button class="example-btn" id="example2">Load Example 2</button>
            </div>

            <textarea
              id="data-input"
              placeholder="Enter your data here...&#10;Format:&#10;Experiment 1:&#10;12.5 13.2 14.1&#10;11.8 12.4 13.0&#10;&#10;Experiment 2:&#10;14.2 14.8 15.3&#10;13.5 13.9 14.5&#10;&#10;(Each experiment must have same number of treatments)"
            ></textarea>

            <div class="input-format">
              <p>
                <strong>Format:</strong> Separate experiments with blank lines.
                Each experiment should have the same number of treatments
                (rows).
              </p>
              <p>Values can be separated by spaces, commas, or tabs.</p>
            </div>

            <button id="analyze-btn" class="btn">
              <i class="fas fa-calculator"></i> Analyze Data
            </button>
          </div>

          <div id="error-message" class="error-message hidden"></div>
        </div>

        <div class="output-section">
          <div class="section-title">
            <i class="fas fa-chart-bar"></i>
            <h2>Results</h2>
          </div>

          <div id="data-info" class="output-card hidden">
            <h3>Experimental Information</h3>
            <div class="data-info-grid">
              <div class="info-card">
                <h3>Experiments</h3>
                <p id="experiment-count">0</p>
              </div>
              <div class="info-card">
                <h3>Treatments</h3>
                <p id="treatment-count">0</p>
              </div>
              <div class="info-card">
                <h3>Replications</h3>
                <p id="replication-count">0</p>
              </div>
              <div class="info-card">
                <h3>Total Observations</h3>
                <p id="total-observations">0</p>
              </div>
            </div>
          </div>

          <div id="anova-results" class="output-card hidden">
            <h3>Pooled ANOVA Table</h3>
            <table id="anova-table">
              <thead>
                <tr>
                  <th>Source</th>
                  <th>df</th>
                  <th>SS</th>
                  <th>MS</th>
                  <th>F-value</th>
                  <th>p-value</th>
                  <th>Sig.</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="treatment-means" class="output-card hidden">
            <h3>Treatment Means Across Experiments</h3>
            <table id="means-table">
              <thead>
                <tr>
                  <th>Treatment</th>
                  <th>Mean</th>
                  <th>Std. Error</th>
                  <th>95% CI Lower</th>
                  <th>95% CI Upper</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="charts-container" class="hidden">
            <div class="section-title">
              <i class="fas fa-chart-line"></i>
              <h2>Visualizations</h2>
            </div>

            <div class="charts-row">
              <div class="chart-card">
                <h3 class="chart-title">Treatment Means Comparison</h3>
                <div class="chart-container">
                  <canvas id="meansChart"></canvas>
                </div>
              </div>

              <div class="chart-card">
                <h3 class="chart-title">ANOVA Significance</h3>
                <div class="chart-container">
                  <canvas id="significanceChart"></canvas>
                </div>
              </div>
            </div>

            <div class="charts-row">
              <div class="chart-card">
                <h3 class="chart-title">Treatment Variability</h3>
                <div class="chart-container">
                  <canvas id="variabilityChart"></canvas>
                </div>
              </div>

              <div class="chart-card">
                <h3 class="chart-title">Experiment Comparison</h3>
                <div class="chart-container">
                  <canvas id="experimentChart"></canvas>
                </div>
              </div>
            </div>
          </div>

          <div class="export-buttons hidden" id="export-section">
            <button class="btn btn-secondary export-btn" id="export-csv">
              <i class="fas fa-file-csv"></i> Export to CSV
            </button>
            <button class="btn btn-secondary export-btn" id="export-json">
              <i class="fas fa-file-code"></i> Export to JSON
            </button>
          </div>
        </div>
      </div>

      <div class="help-text">
        <h3>How to use this calculator:</h3>
        <ul>
          <li>
            <strong>Pooled ANOVA</strong> combines results from multiple
            experiments with the same treatments to increase precision and
            power.
          </li>
          <li>Enter data from each experiment separated by blank lines.</li>
          <li>
            Each experiment must have the same number of treatments (rows).
          </li>
          <li>The number of replications can vary between experiments.</li>
          <li>
            Results include combined F-tests and treatment means across all
            experiments.
          </li>
        </ul>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // DOM Elements
        const analyzeBtn = document.getElementById("analyze-btn");
        const dataInput = document.getElementById("data-input");
        const errorMessage = document.getElementById("error-message");
        const example1Btn = document.getElementById("example1");
        const example2Btn = document.getElementById("example2");

        // Output elements
        const dataInfoSection = document.getElementById("data-info");
        const anovaResults = document.getElementById("anova-results");
        const treatmentMeans = document.getElementById("treatment-means");
        const chartsContainer = document.getElementById("charts-container");
        const exportSection = document.getElementById("export-section");
        const experimentCount = document.getElementById("experiment-count");
        const treatmentCount = document.getElementById("treatment-count");
        const replicationCount = document.getElementById("replication-count");
        const totalObservations = document.getElementById("total-observations");
        const anovaTableBody = document.querySelector("#anova-table tbody");
        const meansTableBody = document.querySelector("#means-table tbody");
        const exportCsvBtn = document.getElementById("export-csv");
        const exportJsonBtn = document.getElementById("export-json");

        // Chart elements
        const meansChartCtx = document
          .getElementById("meansChart")
          .getContext("2d");
        const significanceChartCtx = document
          .getElementById("significanceChart")
          .getContext("2d");
        const variabilityChartCtx = document
          .getElementById("variabilityChart")
          .getContext("2d");
        const experimentChartCtx = document
          .getElementById("experimentChart")
          .getContext("2d");

        // Chart instances
        let meansChart, significanceChart, variabilityChart, experimentChart;

        // Current data
        let currentResult = null;
        let currentData = null;

        // Example data sets
        const examples = {
          1: `Experiment 1:
12.5 13.2 14.1
11.8 12.4 13.0
14.2 14.8 15.3

Experiment 2:
13.5 13.9 14.5
12.8 13.4 14.0
15.2 15.8 16.3`,

          2: `Location A:
10.2 10.5 10.8
12.3 12.6 12.9
11.8 12.1 12.4

Location B:
11.2 11.5 11.8
13.3 13.6 13.9
12.8 13.1 13.4`,
        };

        // Set up example buttons
        example1Btn.addEventListener("click", function () {
          dataInput.value = examples[1];
        });

        example2Btn.addEventListener("click", function () {
          dataInput.value = examples[2];
        });

        // Analyze button click handler
        analyzeBtn.addEventListener("click", function () {
          // Reset UI
          dataInfoSection.classList.add("hidden");
          anovaResults.classList.add("hidden");
          treatmentMeans.classList.add("hidden");
          chartsContainer.classList.add("hidden");
          exportSection.classList.add("hidden");
          errorMessage.classList.add("hidden");

          // Show loading state
          const originalText = analyzeBtn.innerHTML;
          analyzeBtn.innerHTML = `<span class="loading"></span>Analyzing...`;
          analyzeBtn.disabled = true;

          // Use setTimeout to allow UI to update before heavy computation
          setTimeout(() => {
            try {
              const rawData = dataInput.value.trim();
              if (!rawData) throw new Error("Please enter data to analyze");

              currentData = parseData(rawData);
              const result = performPooledANOVA(currentData);

              currentResult = result; // Store for export

              displayDataInfo(result);
              displayANOVATable(result);
              displayTreatmentMeans(result);
              displayCharts(currentData, result);

              exportSection.classList.remove("hidden");
            } catch (error) {
              showError(error.message);
            } finally {
              analyzeBtn.innerHTML = originalText;
              analyzeBtn.disabled = false;
            }
          }, 100);
        });

        function parseData(rawData) {
          const experiments = [];
          let currentExperiment = null;

          const lines = rawData.split("\n");
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            // Check for experiment label (optional)
            if (
              trimmedLine.toLowerCase().includes("experiment") ||
              trimmedLine.toLowerCase().includes("location")
            ) {
              if (currentExperiment) {
                experiments.push(currentExperiment);
              }
              currentExperiment = {
                name: trimmedLine.replace(/[:]/g, "").trim(),
                data: [],
              };
            } else {
              // Parse data line
              if (!currentExperiment) {
                currentExperiment = {
                  name: `Experiment ${experiments.length + 1}`,
                  data: [],
                };
              }

              const values = trimmedLine
                .split(/[\s,]+/)
                .filter((val) => val !== "" && !isNaN(val))
                .map((val) => parseFloat(val));

              if (values.length === 0) continue;
              currentExperiment.data.push(values);
            }
          }

          // Add the last experiment
          if (currentExperiment && currentExperiment.data.length > 0) {
            experiments.push(currentExperiment);
          }

          if (experiments.length === 0)
            throw new Error("No valid experiments found");

          // Check all experiments have same number of treatments
          const numTreatments = experiments[0].data.length;
          if (!experiments.every((exp) => exp.data.length === numTreatments)) {
            throw new Error(
              "All experiments must have the same number of treatments"
            );
          }

          return experiments;
        }

        function performPooledANOVA(experiments) {
          const numExperiments = experiments.length;
          const numTreatments = experiments[0].data.length;

          // Calculate basic statistics for each experiment
          experiments.forEach((exp) => {
            exp.treatmentTotals = exp.data.map((treatment) =>
              treatment.reduce((sum, val) => sum + val, 0)
            );
            exp.treatmentMeans = exp.treatmentTotals.map(
              (total) => total / exp.data[0].length
            );
            exp.grandTotal = exp.treatmentTotals.reduce(
              (sum, total) => sum + total,
              0
            );
            exp.grandMean =
              exp.grandTotal / (numTreatments * exp.data[0].length);

            // Calculate SS for this experiment
            exp.SST = 0;
            exp.data.forEach((treatment, i) => {
              treatment.forEach((value) => {
                exp.SST += Math.pow(value - exp.grandMean, 2);
              });
            });

            exp.SSTreatment =
              exp.treatmentTotals.reduce(
                (sum, total) => sum + Math.pow(total, 2) / exp.data[0].length,
                0
              ) -
              Math.pow(exp.grandTotal, 2) /
                (numTreatments * exp.data[0].length);

            exp.SSE = exp.SST - exp.SSTreatment;
          });

          // Calculate pooled statistics
          const pooledTreatmentTotals = Array(numTreatments).fill(0);
          let pooledGrandTotal = 0;
          let totalObservations = 0;

          experiments.forEach((exp) => {
            exp.treatmentTotals.forEach((total, i) => {
              pooledTreatmentTotals[i] += total;
            });
            pooledGrandTotal += exp.grandTotal;
            totalObservations += numTreatments * exp.data[0].length;
          });

          const pooledGrandMean = pooledGrandTotal / totalObservations;

          // Calculate pooled SS
          let pooledSSTreatment = 0;
          let sumOfSquares = 0;

          experiments.forEach((exp) => {
            exp.data.forEach((treatment, i) => {
              treatment.forEach((value) => {
                sumOfSquares += Math.pow(value - pooledGrandMean, 2);
              });
            });
          });

          const CF = Math.pow(pooledGrandTotal, 2) / totalObservations;
          pooledSSTreatment =
            pooledTreatmentTotals.reduce(
              (sum, total) =>
                sum +
                Math.pow(total, 2) /
                  experiments.reduce((sum, exp) => sum + exp.data[0].length, 0),
              0
            ) - CF;

          const pooledSSExperiment =
            experiments.reduce(
              (sum, exp) =>
                sum +
                Math.pow(exp.grandTotal, 2) /
                  (numTreatments * exp.data[0].length),
              0
            ) - CF;

          const pooledSSE = experiments.reduce((sum, exp) => sum + exp.SSE, 0);

          // Calculate degrees of freedom
          const dfTreatment = numTreatments - 1;
          const dfExperiment = numExperiments - 1;
          const dfError = experiments.reduce(
            (sum, exp) => sum + (numTreatments - 1) * (exp.data[0].length - 1),
            0
          );

          // Calculate mean squares
          const MSTreatment = pooledSSTreatment / dfTreatment;
          const MSExperiment = pooledSSExperiment / dfExperiment;
          const MSE = pooledSSE / dfError;

          // Calculate F-values
          const FTreatment = MSTreatment / MSE;
          const FExperiment = MSExperiment / MSE;

          // Calculate p-values
          const pValueTreatment = calculatePValue(
            FTreatment,
            dfTreatment,
            dfError
          );
          const pValueExperiment = calculatePValue(
            FExperiment,
            dfExperiment,
            dfError
          );

          // Calculate treatment means across experiments
          const treatmentMeans = pooledTreatmentTotals.map(
            (total) =>
              total /
              experiments.reduce((sum, exp) => sum + exp.data[0].length, 0)
          );

          // Calculate standard errors and confidence intervals
          const treatmentSEs = treatmentMeans.map((mean) =>
            Math.sqrt(
              MSE /
                experiments.reduce((sum, exp) => sum + exp.data[0].length, 0)
            )
          );

          const tCritical = getTCriticalValue(dfError);
          const treatmentCIs = treatmentSEs.map((se, index) => {
            const mean = treatmentMeans[index];
            return {
              lower: mean - tCritical * se,
              upper: mean + tCritical * se,
            };
          });

          // Calculate coefficient of variation
          const CV = (Math.sqrt(MSE) / pooledGrandMean) * 100;

          return {
            numExperiments: numExperiments,
            numTreatments: numTreatments,
            replications: experiments[0].data[0].length,
            totalObservations: totalObservations,
            pooledGrandMean: pooledGrandMean,
            treatmentMeans: treatmentMeans,
            treatmentSEs: treatmentSEs,
            treatmentCIs: treatmentCIs,
            SST: sumOfSquares,
            SSTreatment: pooledSSTreatment,
            SSExperiment: pooledSSExperiment,
            SSE: pooledSSE,
            dfTreatment: dfTreatment,
            dfExperiment: dfExperiment,
            dfError: dfError,
            MSTreatment: MSTreatment,
            MSExperiment: MSExperiment,
            MSE: MSE,
            FTreatment: FTreatment,
            FExperiment: FExperiment,
            pValueTreatment: pValueTreatment,
            pValueExperiment: pValueExperiment,
            CV: CV,
            experiments: experiments,
          };
        }

        // F-distribution p-value calculation
        function calculatePValue(F, df1, df2) {
          if (F <= 0 || df1 <= 0 || df2 <= 0 || !isFinite(F)) return 1;

          // Implementation using regularized incomplete beta function
          try {
            const x = df2 / (df2 + df1 * F);
            return incompleteBeta(x, df2 / 2, df1 / 2);
          } catch (e) {
            console.error("P-value calculation error:", e);
            return 1;
          }
        }

        // Incomplete beta function implementation
        function incompleteBeta(x, a, b) {
          if (x <= 0) return 0;
          if (x >= 1) return 1;
          if (a <= 0 || b <= 0) return 1;

          // Use continued fraction approximation when x < (a+1)/(a+b+2)
          if (x < (a + 1) / (a + b + 2)) {
            return (
              ((Math.pow(x, a) * Math.pow(1 - x, b)) / (a * beta(a, b))) *
              continuedFraction(x, a, b)
            );
          } else {
            // Use symmetry property I_x(a,b) = 1 - I_{1-x}(b,a)
            return 1 - incompleteBeta(1 - x, b, a);
          }
        }

        // Continued fraction approximation for incomplete beta
        function continuedFraction(x, a, b) {
          const maxIterations = 100;
          const epsilon = 1e-10;

          let result = 1;
          let c = 1;
          let d = 1 - ((a + b) * x) / (a + 1);

          if (Math.abs(d) < epsilon) d = epsilon;
          d = 1 / d;
          let h = d;

          for (let i = 1; i <= maxIterations; i++) {
            const m = i / 2;
            let numerator;

            if (i % 2 === 0) {
              numerator = (m * (b - m) * x) / ((a + 2 * m - 1) * (a + 2 * m));
            } else {
              numerator =
                -((a + m) * (a + b + m) * x) / ((a + 2 * m) * (a + 2 * m + 1));
            }

            d = 1 + numerator * d;
            if (Math.abs(d) < epsilon) d = epsilon;
            d = 1 / d;

            c = 1 + numerator / c;
            if (Math.abs(c) < epsilon) c = epsilon;

            const delta = c * d;
            h *= delta;

            if (Math.abs(delta - 1) < epsilon) break;
          }

          return h;
        }

        // Beta function using gamma functions
        function beta(a, b) {
          return Math.exp(logGamma(a) + logGamma(b) - logGamma(a + b));
        }

        // Natural log of gamma function using Lanczos approximation
        function logGamma(z) {
          // Lanczos coefficients
          const g = 7;
          const p = [
            0.99999999999980993, 676.5203681218851, -1259.1392167224028,
            771.32342877765313, -176.61502916214059, 12.507343278686905,
            -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
          ];

          // Reflection formula
          if (z < 0.5) {
            return (
              Math.log(Math.PI) -
              Math.log(Math.sin(Math.PI * z)) -
              logGamma(1 - z)
            );
          }

          z -= 1;
          let x = p[0];
          for (let i = 1; i < p.length; i++) {
            x += p[i] / (z + i);
          }
          const t = z + g + 0.5;

          return (
            0.5 * Math.log(2 * Math.PI) +
            (z + 0.5) * Math.log(t) -
            t +
            Math.log(x)
          );
        }

        // Get critical t-value for confidence intervals
        function getTCriticalValue(df, alpha = 0.05) {
          // Approximation for two-tailed t-distribution
          if (df <= 0) return 1.96; // Fallback to normal for invalid df

          // For large df, use normal approximation
          if (df > 100) return 1.96;

          // Table of critical values for common df at alpha=0.05
          const tTable = {
            1: 12.706,
            2: 4.303,
            3: 3.182,
            4: 2.776,
            5: 2.571,
            6: 2.447,
            7: 2.365,
            8: 2.306,
            9: 2.262,
            10: 2.228,
            11: 2.201,
            12: 2.179,
            13: 2.16,
            14: 2.145,
            15: 2.131,
            16: 2.12,
            17: 2.11,
            18: 2.101,
            19: 2.093,
            20: 2.086,
            25: 2.06,
            30: 2.042,
            40: 2.021,
            60: 2.0,
            120: 1.98,
          };

          // Find closest df in table
          const dfs = Object.keys(tTable)
            .map(Number)
            .sort((a, b) => a - b);
          let lower = dfs[0];
          let upper = dfs[dfs.length - 1];

          for (const d of dfs) {
            if (d <= df) lower = d;
            if (d >= df) {
              upper = d;
              break;
            }
          }

          // Linear interpolation if df is between table values
          if (lower === upper) return tTable[lower];
          return (
            tTable[lower] +
            ((tTable[upper] - tTable[lower]) * (df - lower)) / (upper - lower)
          );
        }

        function displayDataInfo(result) {
          experimentCount.textContent = result.numExperiments;
          treatmentCount.textContent = result.numTreatments;
          replicationCount.textContent = result.replications;
          totalObservations.textContent = result.totalObservations;
          dataInfoSection.classList.remove("hidden");
        }

        function displayANOVATable(result) {
          anovaTableBody.innerHTML = "";

          // Treatment row
          addANOVATableRow(
            "Treatment",
            result.dfTreatment,
            result.SSTreatment,
            result.MSTreatment,
            result.FTreatment,
            result.pValueTreatment
          );

          // Experiment row
          addANOVATableRow(
            "Experiment",
            result.dfExperiment,
            result.SSExperiment,
            result.MSExperiment,
            result.FExperiment,
            result.pValueExperiment
          );

          // Error row
          addANOVATableRow(
            "Error",
            result.dfError,
            result.SSE,
            result.MSE,
            null,
            null
          );

          // Total row
          addANOVATableRow(
            "Total",
            result.dfTreatment + result.dfExperiment + result.dfError,
            result.SST,
            null,
            null,
            null
          );

          // Add CV row
          const cvRow = document.createElement("tr");
          cvRow.style.fontWeight = "bold";

          const cvCell = document.createElement("td");
          cvCell.colSpan = 7;
          cvCell.textContent = `Coefficient of Variation (CV): ${result.CV.toFixed(
            2
          )}%`;
          cvRow.appendChild(cvCell);

          anovaTableBody.appendChild(cvRow);

          anovaResults.classList.remove("hidden");
        }

        function displayTreatmentMeans(result) {
          meansTableBody.innerHTML = "";

          result.treatmentMeans.forEach((mean, i) => {
            const row = document.createElement("tr");

            row.appendChild(createTableCell(`Treatment ${i + 1}`));
            row.appendChild(createTableCell(mean.toFixed(4)));
            row.appendChild(createTableCell(result.treatmentSEs[i].toFixed(4)));
            row.appendChild(
              createTableCell(result.treatmentCIs[i].lower.toFixed(4))
            );
            row.appendChild(
              createTableCell(result.treatmentCIs[i].upper.toFixed(4))
            );

            meansTableBody.appendChild(row);
          });

          treatmentMeans.classList.remove("hidden");
        }

        function displayCharts(experiments, result) {
          // Destroy previous charts if they exist
          if (meansChart) meansChart.destroy();
          if (significanceChart) significanceChart.destroy();
          if (variabilityChart) variabilityChart.destroy();
          if (experimentChart) experimentChart.destroy();

          // Prepare data for charts
          const treatmentLabels = result.treatmentMeans.map(
            (_, i) => `T${i + 1}`
          );

          // 1. Treatment Means Comparison Chart
          meansChart = new Chart(meansChartCtx, {
            type: "bar",
            data: {
              labels: treatmentLabels,
              datasets: [
                {
                  label: "Mean Value",
                  data: result.treatmentMeans,
                  backgroundColor: "rgba(54, 162, 235, 0.7)",
                  borderColor: "rgba(54, 162, 235, 1)",
                  borderWidth: 1,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: "Mean Value",
                  },
                },
              },
              plugins: {
                title: {
                  display: true,
                  text: "Comparison of Treatment Means",
                },
              },
            },
          });

          // 2. ANOVA Significance Chart
          significanceChart = new Chart(significanceChartCtx, {
            type: "bar",
            data: {
              labels: ["Treatment Effect", "Experiment Effect"],
              datasets: [
                {
                  label: "p-value",
                  data: [result.pValueTreatment, result.pValueExperiment],
                  backgroundColor: [
                    result.pValueTreatment < 0.05
                      ? "rgba(255, 99, 132, 0.7)"
                      : "rgba(75, 192, 192, 0.7)",
                    result.pValueExperiment < 0.05
                      ? "rgba(255, 99, 132, 0.7)"
                      : "rgba(75, 192, 192, 0.7)",
                  ],
                  borderColor: [
                    result.pValueTreatment < 0.05
                      ? "rgba(255, 99, 132, 1)"
                      : "rgba(75, 192, 192, 1)",
                    result.pValueExperiment < 0.05
                      ? "rgba(255, 99, 132, 1)"
                      : "rgba(75, 192, 192, 1)",
                  ],
                  borderWidth: 1,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  max: 1,
                  title: {
                    display: true,
                    text: "p-value",
                  },
                },
              },
              plugins: {
                title: {
                  display: true,
                  text: "ANOVA Significance Levels",
                },
                annotation: {
                  annotations: {
                    line1: {
                      type: "line",
                      yMin: 0.05,
                      yMax: 0.05,
                      borderColor: "rgb(255, 0, 0)",
                      borderWidth: 2,
                      borderDash: [6, 6],
                      label: {
                        content: "Significance Threshold (0.05)",
                        enabled: true,
                        position: "right",
                      },
                    },
                  },
                },
              },
            },
          });

          // 3. Treatment Variability Chart
          variabilityChart = new Chart(variabilityChartCtx, {
            type: "line",
            data: {
              labels: treatmentLabels,
              datasets: [
                {
                  label: "Mean Â± SE",
                  data: result.treatmentMeans,
                  backgroundColor: "rgba(75, 192, 192, 0.2)",
                  borderColor: "rgba(75, 192, 192, 1)",
                  borderWidth: 2,
                  pointRadius: 4,
                  pointHoverRadius: 6,
                  fill: true,
                },
                {
                  label: "95% Confidence Interval",
                  data: result.treatmentMeans,
                  backgroundColor: "rgba(255, 159, 64, 0.2)",
                  borderColor: "rgba(255, 159, 64, 1)",
                  borderWidth: 2,
                  borderDash: [5, 5],
                  pointRadius: 4,
                  pointHoverRadius: 6,
                  fill: false,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: "Value",
                  },
                },
              },
              plugins: {
                title: {
                  display: true,
                  text: "Treatment Means with Confidence Intervals",
                },
              },
            },
          });

          // 4. Experiment Comparison Chart
          const experimentLabels = experiments.map((exp) => exp.name);
          const experimentData = experiments.map((exp) => exp.grandMean);

          experimentChart = new Chart(experimentChartCtx, {
            type: "bar",
            data: {
              labels: experimentLabels,
              datasets: [
                {
                  label: "Experiment Mean",
                  data: experimentData,
                  backgroundColor: "rgba(153, 102, 255, 0.7)",
                  borderColor: "rgba(153, 102, 255, 1)",
                  borderWidth: 1,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: "Mean Value",
                  },
                },
              },
              plugins: {
                title: {
                  display: true,
                  text: "Comparison of Experiment Means",
                },
              },
            },
          });

          // Show charts container
          chartsContainer.classList.remove("hidden");
        }

        function addANOVATableRow(source, df, SS, MS, F, pValue) {
          const row = document.createElement("tr");

          // Source
          row.appendChild(createTableCell(source));

          // Degrees of Freedom
          row.appendChild(createTableCell(df.toFixed(df % 1 === 0 ? 0 : 2)));

          // Sum of Squares
          row.appendChild(createTableCell(SS.toFixed(4)));

          // Mean Square
          row.appendChild(createTableCell(MS ? MS.toFixed(4) : ""));

          // F-value
          row.appendChild(createTableCell(F ? F.toFixed(4) : ""));

          // p-value
          const pCell = document.createElement("td");
          if (pValue) {
            pCell.textContent = pValue < 0.0001 ? "<0.0001" : pValue.toFixed(6);
          }
          row.appendChild(pCell);

          // Significance
          const sigCell = document.createElement("td");
          if (pValue) {
            const sigClass = getSignificanceClass(pValue);
            const sigText = getSignificanceStars(pValue);
            sigCell.innerHTML = `<span class="significance ${sigClass}">${sigText}</span>`;
          }
          row.appendChild(sigCell);

          anovaTableBody.appendChild(row);
        }

        function createTableCell(content) {
          const cell = document.createElement("td");
          cell.textContent = content;
          return cell;
        }

        function getSignificanceStars(pValue) {
          if (!pValue) return "";
          if (pValue < 0.001) return "***";
          if (pValue < 0.01) return "**";
          if (pValue < 0.05) return "*";
          return "ns";
        }

        function getSignificanceClass(pValue) {
          if (!pValue) return "";
          if (pValue < 0.001) return "sig-0";
          if (pValue < 0.01) return "sig-1";
          if (pValue < 0.05) return "sig-2";
          return "";
        }

        function showError(message) {
          errorMessage.textContent = message;
          errorMessage.classList.remove("hidden");

          // Scroll to error message
          errorMessage.scrollIntoView({ behavior: "smooth", block: "center" });
        }

        // Export functionality
        exportCsvBtn.addEventListener("click", function () {
          if (!currentResult) return;

          // Prepare CSV data
          let csvData = "Pooled ANOVA Results\n\n";

          // Experimental design info
          csvData += "Experimental Information\n";
          csvData += `Experiments,${currentResult.numExperiments}\n`;
          csvData += `Treatments,${currentResult.numTreatments}\n`;
          csvData += `Replications,${currentResult.replications}\n`;
          csvData += `Total Observations,${currentResult.totalObservations}\n\n`;

          // ANOVA table
          csvData += "Pooled ANOVA Table\n";
          csvData += "Source,df,SS,MS,F-value,p-value,Sig.\n";

          // Treatment row
          csvData += `Treatment,${
            currentResult.dfTreatment
          },${currentResult.SSTreatment.toFixed(
            4
          )},${currentResult.MSTreatment.toFixed(
            4
          )},${currentResult.FTreatment.toFixed(4)},${
            currentResult.pValueTreatment < 0.0001
              ? "<0.0001"
              : currentResult.pValueTreatment.toFixed(6)
          },${getSignificanceStars(currentResult.pValueTreatment)}\n`;

          // Experiment row
          csvData += `Experiment,${
            currentResult.dfExperiment
          },${currentResult.SSExperiment.toFixed(
            4
          )},${currentResult.MSExperiment.toFixed(
            4
          )},${currentResult.FExperiment.toFixed(4)},${
            currentResult.pValueExperiment < 0.0001
              ? "<0.0001"
              : currentResult.pValueExperiment.toFixed(6)
          },${getSignificanceStars(currentResult.pValueExperiment)}\n`;

          // Error and Total rows
          csvData += `Error,${
            currentResult.dfError
          },${currentResult.SSE.toFixed(4)},${currentResult.MSE.toFixed(
            4
          )},,,\n`;
          csvData += `Total,${
            currentResult.dfTreatment +
            currentResult.dfExperiment +
            currentResult.dfError
          },${currentResult.SST.toFixed(4)},,,\n\n`;
          csvData += `Coefficient of Variation (CV),${currentResult.CV.toFixed(
            2
          )}%\n\n`;

          // Treatment means
          csvData += "Treatment Means\n";
          csvData += "Treatment,Mean,Std. Error,95% CI Lower,95% CI Upper\n";
          currentResult.treatmentMeans.forEach((mean, i) => {
            csvData += `T${i + 1},${mean.toFixed(
              4
            )},${currentResult.treatmentSEs[i].toFixed(
              4
            )},${currentResult.treatmentCIs[i].lower.toFixed(
              4
            )},${currentResult.treatmentCIs[i].upper.toFixed(4)}\n`;
          });

          // Create download link
          const blob = new Blob([csvData], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.setAttribute("href", url);
          link.setAttribute("download", `pooled_anova_results.csv`);
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

        exportJsonBtn.addEventListener("click", function () {
          if (!currentResult) return;

          // Clone the result to avoid modifying the original
          const resultToExport = JSON.parse(JSON.stringify(currentResult));

          // Format numbers for better readability
          Object.keys(resultToExport).forEach((key) => {
            if (typeof resultToExport[key] === "number") {
              resultToExport[key] = parseFloat(resultToExport[key].toFixed(6));
            }
          });

          // Convert to JSON string with pretty printing
          const jsonData = JSON.stringify(resultToExport, null, 2);

          // Create download link
          const blob = new Blob([jsonData], {
            type: "application/json;charset=utf-8;",
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.setAttribute("href", url);
          link.setAttribute("download", `pooled_anova_results.json`);
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      });
    </script>
  </body>
</html>
